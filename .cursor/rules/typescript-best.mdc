---
description: TypeScript chuẩn hóa
globs: ["**/*.ts", "**/*.tsx"]
alwaysApply: true
---
---
description: TypeScript Best Practice Standardization  
alwaysApply: true  
globs: ["**/*.ts", "**/*.tsx"]
---

# TypeScript Best Practices

## Type Safety Rules
- **NEVER use `any`**. Use `unknown` or `TODO: type` placeholder instead
- Prefer `interface` over `type` for component props
- Use branded types for domain entities:
  ```ts
  type UserId = string & { __brand: "UserId" }
  type OrderId = string & { __brand: "OrderId" }
  ```

## Validation
- Use **Zod** or **Yup** to validate all external inputs (forms, APIs)
- Infer types from Zod schemas instead of duplicating:
  ```ts
  const userSchema = z.object({ name: z.string() })
  type User = z.infer<typeof userSchema>
  ```

## Modern Patterns
- **NO enums**. Use union string literals + object maps:
  ```ts
  const Status = { ACTIVE: 'active', INACTIVE: 'inactive' } as const
  type Status = typeof Status[keyof typeof Status]
  ```
- Use `as const` for literals to enforce readonly types
- Use template literal types for dynamic object keys
- Use generic constraints: `<T extends string>`

## Utility Types
- Master TypeScript utilities: `Pick`, `Omit`, `Partial`, `Required`, `Exclude`, `NonNullable`
- Avoid deeply nested types beyond 3 levels — extract to named types
- Declare module types explicitly for third-party packages

## TSConfig Requirements
- Enable in `tsconfig.json`:
  - `strictNullChecks`: true
  - `noImplicitAny`: true
  - `exactOptionalPropertyTypes`: true
  - `strict`: true

## Naming Conventions
- Variable names should have clear prefixes: `is`, `has`, `on`, `handle`, `get`, `set`
- Use PascalCase for types/interfaces, camelCase for variables/functions
- Use UPPER_SNAKE_CASE for constants








